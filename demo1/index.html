<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        async function test () {
            const canvas = document.querySelector('#canvas');
            const ctx = canvas.getContext('webgpu');

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            const presentationFormat = ctx.getPreferredFormat(adapter);
            ctx.configure({
                device,
                format: presentationFormat, // 不同的设备支持的纹理格式不同
                size: [400, 400], // 这里一般就是Canvas的大小
            });

 const triangleVertWGSL =  `[[stage(vertex)]]
fn main([[builtin(vertex_index)]] VertexIndex : u32)
     -> [[builtin(position)]] vec4<f32> {
  var pos = array<vec2<f32>, 3>(
      vec2<f32>(0.0, 0.5),
      vec2<f32>(-0.5, -0.5),
      vec2<f32>(0.5, -0.5));

  return vec4<f32>(pos[VertexIndex], 0.0, 1.0);
}`;

const redFragWGSL = `[[stage(fragment)]]
fn main() -> [[location(0)]] vec4<f32> {
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
}`;

            const pipeline = device.createRenderPipeline({
                vertex: {
                    module: device.createShaderModule({
                        code: triangleVertWGSL,
                    }),
                    entryPoint: 'main',
                },
                fragment: {
                    module: device.createShaderModule({
                        code: redFragWGSL,
                    }),
                    entryPoint: 'main',
                    targets: [{
                        format: presentationFormat,
                    }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            })

            const commandEncoder = device.createCommandEncoder();
            const textureView = ctx.getCurrentTexture().createView();

            const renderPassDescriptor = {
                colorAttachments: [{
                    view: textureView,
                    loadValue: {r: 1.0, g: 1.0, b: 1.0, a:1.0},
                    storeOp: 'store',
                }]
            };
            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setPipeline(pipeline);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.endPass();

            device.queue.submit([commandEncoder.finish()]);
        }

        test();
    </script>
</body>
</html>